---
title: "Tables in R Markdown"
author: "Duncan Murdoch"
date: "13/05/2019"
output:
  bookdown::pdf_document2:
    toc: true
    toc_depth: 3
    link-citations: yes
pkgdown:
  as_is: true
  extension: pdf
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Tables in R Markdown}
bibliography: tables.bib
header-includes: 
  \usepackage{booktabs}
  \usepackage{tabu}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(width=60)
```
```{r echo = FALSE}
if (!requireNamespace("rmarkdown") || !rmarkdown::pandoc_available("1.12.3")) {
  warning("This vignette requires pandoc version 1.12.3; code will not run in older versions.")
  knitr::opts_chunk$set(eval = FALSE)
}
```

# Introduction

This 
vignette  was built using `tables` version `r packageDescription("tables")$Version`.  It is intended to 
show the same content as the `tables.pdf` vignette that
was written in Sweave, but with R Markdown source code.
This has allowed a few simplifications; see Section
\@ref(sec:knitr) for a description of them.

It is a short introduction to the `tables` package.  Inspired by my 20 year old memories
of SAS PROC TABULATE, I decided to write a simple utility to create nice looking tables in Sweave 
documents.  (It now also works in R Markdown documents,
as this vignette illustrates.) For example, we might display summaries of some of Fisher's iris data using the
code
```{r echo=FALSE}
library(tables)
table_options(knit_print = FALSE)
```
```{r iris}
tabular( (Species + 1) ~ (n=1) + Format(digits=2)*
         (Sepal.Length + Sepal.Width)*(mean + sd), data=iris )
```
You can also pass the output through the `toLatex()` function
to produce \LaTeX\ output,
which when processed by `pdflatex` will produce the following table:
```{r echo=FALSE, results='asis'}
toLatex(
  tabular( (Species + 1) ~ (n=1) + Format(digits=2)*
           (Sepal.Length + Sepal.Width)*(mean + sd), data=iris )
  )
```
However, if you are using `rmarkdown` or `knitr` (as this 
document does), `toLatex()` is not necessary.  Just execute 
```{r}
table_options(knit_print = TRUE)
```
at the start of your document, and conversion to \LaTeX\ will
be done automatically when needed.
	
If you prefer the style of table that the \LaTeX\ `booktabs` package [@booktabs]
produces, you can choose
that style instead.  I mostly like it, so I have used
```{r eval=FALSE}
booktabs()
```
for the rest of this document.  This gives

```{r irisbook,echo=FALSE}
saved.options <- table_options()
invisible(booktabs())
tabular( (Species + 1) ~ (n=1) + Format(digits=2)*
         (Sepal.Length + Sepal.Width)*(mean + sd), data=iris )
```


Details on `booktabs()` are given in section \@ref(sec:booktabs) below.

There is also the `toHTML` function and `html.tabular`
method for the `Hmisc::html()` generic;
they produce output in HTML format.  Finally, see section \@ref(sec:csv) for other 
output formats.

The idea of a table in the `tables` package is a rectangular array of values, with
each row and column labelled, and possibly with groups of rows and groups of columns
also labelled.  These arrays are specified by "table formulas".

Table formulas are R formula objects, with the  rows of the table
described before the tilde (`"~"`), and the columns after.   Each of
those is an expression containing `"*"`, `"+"`, `"="`, as
well as functions, function calls and variables, and parentheses for
grouping.  There are also various directives included in the formula,
entered as "pseudo-functions", i.e. expressions that look like function
calls but which are interpreted by the `tabular()` function.

For example, in the formula 
```r
(Species + 1) ~ (n=1) + Format(digits=2)*
         (Sepal.Length + Sepal.Width)*(mean + sd)
```
the rows are given by \verb!(Species + 1)!.  The summation here is interpreted as concatenation, i.e.
this says rows for `Species` should be followed by rows for `1`.

In the `iris` dataframe, `Species` is a factor, so the rows for it correspond to its levels.

The `1` is a place-holder, which in this context will mean "all groups".

The columns in the table are defined by
```r
(n=1) + Format(digits=2)*(Sepal.Length + Sepal.Width)*(mean + sd)
```
Again, summation corresponds to concatenation, so the first column corresponds to `(n=1)`.
This is another use of the placeholder, but this time it is labelled as `n`.
Since we haven't specified any other statistic to use, the first
column contains the counts of values in the dataframe in each category.

The second term in the column formula is a product of three factors.
The first, `Format(digits=2)`, is a pseudo-function to set the format for all of the entries to
come.  (For more on formats, see section \@ref(sec:formats) below.)  The second factor, `(Sepal.Length
+ Sepal.Width)`, is a concatenation of two variables.  Both of these
variables are numeric vectors in `iris`, and they each become the
variable to be analyzed, in turn.  The last factor, `(mean + sd)`
names two R functions.  These are assumed to be functions that
operate on a vector and produce a single value, as `mean` and
`sd` do.  The values in the table will be the results of applying
those functions to the two different variables and the subsets of the
dataset.

# Reference

For the examples below we use the following definitions:
```{r results = 'markup'}
set.seed(100)
X <- rnorm(10)
X
A <- sample(letters[1:2], 10, rep=TRUE)
A
F <- factor(A)
F
```

## Function syntax

### `tabular()`

```r
tabular(table, ...)
tabular.default(table, ...)
tabular.formula(table, data=parent.frame(), n, suppressLabels=0, ...) 
```

The `tabular` function is a generic function.  The default method
uses `as.formula()` to try to convert the `table` argument
to a formula, then passes it and all the other arguments to 
`tabular.formula()` method, which does most of the work.  That
method has 4 arguments plus `...`, but usually only the first two
are used, and a warning is issued if anything is passed in the
`...` arguments.

- `table`: The `table` argument is the table formula, described in detail below.

- `data`: The `data` argument is a dataframe or environment in which to look for 
the data referenced by the table.

- `n`: The `tabular` function needs to know the length of vectors on which it operates, because 
some formulas (e.g. `1 ~ 1`) contain no data.  Normally `n` is taken as the
number of rows in `data`, or the length of the first referenced object in the formula,
but sometimes the user will need to specify it.  Once specified, it can't be modified:
all data in the table should be the same length.

- `suppressLabels`: By default, `tabular` adds a row or column label for each term, but
this does sometimes make the table messy.  Setting `suppressLabels` to a positive
integer will cause that many labels to be suppressed at the start of each term.  The
pseudo-function `Heading()` can achieve the same effect, one term at a time.

The value returned is a list-mode matrix corresponding to the entries in the table, 
with a number of attributes to help with formatting.  See the `?tabular` help page
for more details.

### `format(), print(), toLatex()` {#sec:formatsyntax}

```r
format(x, digits=4, justification="n", ...) 
print(x, ...)
toLatex(x, file="", options=NULL,  ...)
```


The `tables` package provides methods for the `format()`, `print()` 
and `utils::toLatex()` generics.
The arguments are:

- `x`: The tabular object returned from `tabular()`.
- `digits`: The default number of digits to use when formatting.
- `justification`: The default text justification to use when printing.  For text display, the
recognized values are `"n", "l", "c", "r"`, standing for none, left, center and right
justification respectively.  For \LaTeX\ the justification is 
specified via the `table_options()` function (section \@ref(sec:booktabs)).
- `file`: The default method for the `Hmisc::latex()` generic writes the \LaTeX\ code
to a file; `latex.tabular()` can optionally do the same, but it defaults to writing to screen,
for use in Sweave documents like this one.
- `options`: A list of options to pass to `table_options()`.  These
will be set only for the duration of the call to `toLatex()`.

### `as.matrix(), write.csv.tabular(), write.table.tabular()` {#sec:csv}

```r
as.matrix(x, format = TRUE, 
    rowLabels = TRUE, colLabels = TRUE, justification = "n", ...)
write.csv.tabular(x, file = "", justification = "n", row.names=FALSE, 
    write.options=list(), ...)
write.table.tabular(x, file="", 
    justification = "n", row.names=FALSE, col.names=FALSE,
    write.options=list(), ...) 
```

These functions export tables for further computations.  The arguments are:

- `x`: The tabular object.
- `format`: Whether to format the entries.  See the help page for alternatives.
- `rowLabels, colLabels`: If formatting, whether to include the labels or not.
- `justification`: The default text justification to use when formatting.
- `file`: Where to write the output.
- `row.names,col.names, write.options`: Additional parameters to pass
to `write.csv()` or `write.table()`.

### `as.tabular()`

```r
as.tabular(x, ...)
as.tabular.default(x, like=NULL, ...)
as.tabular.data.frame(x, ...)
```

These functions create tables from existing matrices or dataframes of values.
The dimnames of the input are used to construct default row and column names.  If 
more elaborate labelling is wanted, use a `tabular` object as the
`like` argument.  The labelling for `like` will be used on the
newly constructed result.

### `table_options(), booktabs()` {#sec:booktabs}


The `table_options()` function sets a number of formatting defaults for the `toLatex()`
method:

- `justification`: This is the default justification for data columns and their headers.
Any justification string will be accepted; it should be
one that the \LaTeX\ \verb+\tabular+ environment (or substitute) accepts.  If a vector
of strings is specified they will be recycled across the columns of the table.
- `rowlabeljustification`: This is the default justification for row labels.  A vector of
strings will be recycled across the row label columns.
- `tabular`: The environment to use in \LaTeX.  Alternatives to `"tabular"` such as
`"longtable"` can be used here.  Those often also need 
modifications within the table; the `Literal()` (section \ref{sec:Literal`) function may be
helpful.
- `toprule, midrule, bottomrule`: The \LaTeX\ macros to draw the top, middle and bottom lines
in the table.  By default these are all \verb!"\\hline"!.
- `titlerule`: An optional \LaTeX\ macro to draw a line under multicolumn titles.
- `doBegin, doHeader, doBody, doFooter, doEnd`:
These logical values control the inclusion of specific parts of
the output table.

The defaults are
```{r echo=FALSE}
saved.options
```
Some options only apply to HTML output; see the help page 
`?table_options` for details.

If you are using the \LaTeX\ `booktabs` package, the `booktabs()` function will
set different options.  Currently those are:
```{r echo=FALSE}
table_options()[c("toprule", "midrule", "bottomrule", "titlerule")]
```

The earlier table of iris data was produced using
```{r irisbook, eval=FALSE}
```


We can use the `doXXXX` options to insert raw \LaTeX\ into a table:

```{r split, eval=FALSE}
toLatex(tabular(Species ~ (n=1) + Format(digits=2)*
         (Sepal.Length + Sepal.Width)*(mean + sd), data=iris),
      options=list(doFooter=FALSE, doEnd=FALSE))
cat("\\ \\\\ \\multicolumn{6}{l}{
\\textit{Overall, we see the following: }} \\\\
\\ \\\\")
toLatex(tabular(1 ~ (n=1) + Format(digits=2)*
         (Sepal.Length + Sepal.Width)*(mean + sd), data=iris),
      options=list(doBegin=FALSE, doHeader=FALSE))
```
```{r echo=FALSE, results = "asis"}
toLatex(tabular(Species ~ (n=1) + Format(digits=2)*
         (Sepal.Length + Sepal.Width)*(mean + sd), data=iris),
      options=list(doFooter=FALSE, doEnd=FALSE))
cat("\\ \\\\ \\multicolumn{6}{l}{
\\textit{Overall, we see the following: }} \\\\
\\ \\\\")
toLatex(tabular(1 ~ (n=1) + Format(digits=2)*
         (Sepal.Length + Sepal.Width)*(mean + sd), data=iris),
      options=list(doBegin=FALSE, doHeader=FALSE))
```

Note that we need explicit `toLatex()` calls to access
these options; in turn, that means the `knitr` chunk options
require `results = "asis"`.

### `latexNumeric()` {#sec:latexNumeric}

```{r eval=FALSE}
latexNumeric(chars, minus = TRUE, leftpad = TRUE, rightpad=TRUE, 
                        mathmode = TRUE)
```

The `latexNumeric()` function converts character representations of numbers
into a format suitable for display in \LaTeX\ documents.  There are two goals:

-  If `chars` is a vector with constant width, then the output will also be constant width.
This means the default centering used in `tabular()` will not misalign decimal points (if
they were aligned in `chars`).
-  Minus signs will be displayed with the proper symbol rather than a hyphen.


The arguments are:

- `chars`:
A character vector of formatted numeric values.
- `minus`:
Whether to pad positive cases with spacing of the same width as a minus sign.  If `TRUE`
and some entries are negative, then all positive entries will be padded.
- `leftpad, rightpad`:
Whether to pad cases that have leading or trailing blanks with spacing matching a digit width per space.
If `leftpad=TRUE`, leading blanks will be converted to spaces the same width as a digit 0.  (If
`minus=TRUE`, one leading blank may have been consumed in the sign padding.)
The `rightpad` argument handles trailing blanks similarly.

- `mathmode`:
Whether to wrap the result in dollar signs, so \LaTeX\ will render minus signs properly.


## Operators


### $e_1 + e_2$

Summing two expressions indicates that they
should be displayed in sequence.  For rows, this means $e_1$ will be
displayed just above $e_2$; for columns, $e_1$ will be just to the left of
$e_2$.

Example:

```{r}
tabular(F + 1 ~ 1)
```


### $e_1 * e_2$

Multiplying two expressions means that each
element of $e_1$ will be applied to each element of $e_2$.  If $e_1$ is 
a factor, then $e_2$ will be displayed for each element of it.   NB:  $*$ has
higher precedence than $+$ and evaluation proceeds from left to right.
The expression $(e_1 + e_2)*(e_3 + e_4)$
is equivalent to $e_1*e_3 + e_1*e_4 + e_2*e_3 + e_2*e_4$.

Example:

```{r}
tabular( X*F*(mean + sd) ~ 1 )
```


### $e_1 \sim e_2$

The tilde separates row specifications from
column specifications, but otherwise acts the same as $*$, i.e.
each row value applies to each column.

Example:

```{r}
tabular( X*F ~ mean + sd )
```


### $e_1 = e_2$

The operator $=$ is used to set the name of
$e_2$ to a displayed version of $e_1$.  It is an abbreviation for
`Heading(`$e_1$`)*`$e_2$.  NB:  because $=$ has lower 
operator precedence than any other operator, we usually put
parentheses around these expressions, i.e. $(e_1 = e_2)$.

Example: `F` is renamed to `Newname`.

```{r}
tabular( X*(Newname=F) ~ mean + sd )
```


## Terms in Formulas

R parses table formulas into sums, products, and bindings separated by the tilde formula operator.  What comes between the
operators are other expressions.  Other than the pseudo-functions described in section \ref{sec:pseudo}, these are evaluated
and the actions depend on the type of the resulting value.

### Closures or other functions {#sec:closures}

If the expression evaluates to a function (e.g. it is the name of a function), then that function
becomes the summary statistic to be displayed.  The summary statistic should take a vector of values as input, and return a single 
value (either numeric, character, or some other simple printable value).  If no summary function is specified, the default is
`length`, to count the length of the vector being passed.

Note that only one summary function can be specified for any cell in the table or an error will be
reported.

Example: `mean` and `sd` are specified functions; `n` is the renamed default statistic.

```{r}
tabular( (F+1) ~ (n=1) + X*(mean + sd) )
```


### Factors

If the expression evaluates to a factor, the dataset is broken up into subgroups according to the levels of the factor.
Most of the examples above have shown this for the factor `F`, but this can also be used to display complete datasets:

Example:  creating a factor to show all data.  Use the `identity` function to
display the values in each cell.

```{r}
tabular( (i = factor(seq_along(X)))  ~ 
       Heading()*identity*(X+A + 
              (F = as.character(F) ) ) )
```
 

### Logical vectors

If the expression evaluates to a logical vector, it is used to subset the data.

Example:  creating subsets on the fly. 

```{r}
tabular( (X > 0) + (X < 0)  + 1
    ~ ((n = 1) + X*(mean + sd)) )
```
 

### Language Expressions

If the expression evaluates to a language object, e.g. the result of `quote()` or `substitute()`, 
then it will be replaced in the table formula by its result.  This allows complicated table formulas
to be saved and re-used.  For examples, see section \ref{sec:tableformulas}.


### Other vectors {#sec:othervectors}


If the expression evaluates to something other than the above, then it
is assumed to be a vector of values to be summarized in the table.  If
you would like to summarize a factor or logical vector, wrap it in
`I()` to prevent special handling.

Note that the following must all be true, or an error will be reported:

-  only one value vector can be specified for any cell in the
table, 
-  all value vectors must be the same length, 
-  `is.atomic()`
must evaluate to `TRUE` for the vector.


Example:  treating a logical vector as values.

```{r}
tabular( I(X > 0) + I(X < 0)
    ~ ((n=1) + mean + sd) )
```
 

## "Pseudo-functions" {#sec:pseudo}

Several directives to `tables` may be embedded in the table formula.
This is done using "pseudo-functions".  Syntactically
they look like function calls, but reserved names are used.  In most cases, 
their action applies to later factors in the term in which they appear.
For example,

```r
X*Justify(r)*(Y + Format(digits=2)*Z) + A
```

will apply the `Justify(r)` directive to both `Y` and `Z`, but
the `Format(digits=2)` directive will only apply to `Z`, and neither will apply to `A`.

### `Format()` {#sec:formats}

By default `tables` formats each column
using the standard `format()` function, with arguments taken from the
`format.tabular()` call (see section \ref{sec:formatsyntax}).

The `Format()` pseudo-function does two
things:  it changes the formatting, and it specifies that all values it applies to will be formatted together.
The "call" to `Format` looks like a call to `format`, but without
specifying the argument `x`.  When `tabular()` formats the output it will construct
`x` from the entries in the table governed by the `Format()` specification.

Example:  The mean and standard deviation are both governed by the same format, so
they are displayed with the same number of decimal places, chosen so that the smallest
values (the means) show two significant digits.

```{r}
tabular( (F+1) ~ (n=1) 
           + Format(digits=2)*X*(mean + sd) )
```


For customized formatting, an alternate syntax is to pass a function call to `Format()`, rather
than a list of arguments.  The function should accept an argument named `x` (but as with the
regular formatting, `x` should not be included in the formula), to contain the data.  It should return a character vector
of the same length as x.

Example:  Use a custom function and `sprintf()` to display a standard error in parentheses.

```{r}
stderr <- function(x) sd(x)/sqrt(length(x))
fmt <- function(x, digits, ...) {
  s <- format(x, digits=digits, ...)
  is_stderr <- (1:length(s)) > length(s) %/% 2
  s[is_stderr] <- sprintf("$(%s)$", s[is_stderr])
  s[!is_stderr] <- latexNumeric(s[!is_stderr])
  s
}
tabular( Format(fmt(digits=1))*(F+1) ~ X*(mean + stderr) )
```
